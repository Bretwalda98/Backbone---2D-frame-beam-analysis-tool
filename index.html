<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Backbone – 2D Frame/Beam (MVP)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
  <style>
    html,body{height:100%}
    .card{border-radius:1rem; box-shadow:0 10px 20px rgba(0,0,0,.08)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    @media print{.no-print{display:none!important} .card{box-shadow:none;border:1px solid #999}}
    canvas{image-rendering: crisp-edges}
  </style>
</head>
<body class="bg-zinc-50 text-zinc-900">
  <div class="max-w-[1400px] mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-[380px,1fr] gap-4">
    <!-- Sidebar: model inputs -->
    <aside class="card bg-white p-4 space-y-4">
      <header class="flex items-center justify-between">
        <h1 class="text-xl font-semibold">Backbone (MVP)</h1>
        <span class="text-xs text-zinc-500">HTML + JS + math.js</span>
      </header>

      <div class="grid grid-cols-2 gap-2">
        <button id="btnSample" class="no-print px-3 py-2 rounded-xl bg-zinc-900 text-white hover:bg-zinc-800">Load sample</button>
        <button id="btnRun" class="no-print px-3 py-2 rounded-xl bg-emerald-600 text-white hover:bg-emerald-500">Run analysis</button>
      </div>

      <!-- Example cases -->
      <section>
        <h2 class="font-semibold mb-1">Example cases</h2>
        <div class="space-y-2">
          <button onclick="loadCantilever()" class="px-2 py-1 bg-zinc-100 rounded hover:bg-zinc-200 w-full text-left">Cantilever beam with point load</button>
          <button onclick="loadSimplySupported()" class="px-2 py-1 bg-zinc-100 rounded hover:bg-zinc-200 w-full text-left">Simply supported beam with UDL</button>
          <button onclick="loadPortalFrame()" class="px-2 py-1 bg-zinc-100 rounded hover:bg-zinc-200 w-full text-left">Portal frame with lateral load</button>
          <button onclick="loadTwoSpan()" class="px-2 py-1 bg-zinc-100 rounded hover:bg-zinc-200 w-full text-left">Two-span continuous beam with point load</button>
        </div>
      </section>

      <!-- Materials (simple) -->
      <section>
        <h2 class="font-semibold mb-1">Materials</h2>
        <div class="space-y-2" id="materials"></div>
        <button class="no-print text-sm text-indigo-600" onclick="addMaterial()">+ Add material</button>
      </section>

      <!-- Nodes -->
      <section>
        <h2 class="font-semibold mb-1">Nodes</h2>
        <div id="nodes" class="space-y-2"></div>
        <button class="no-print text-sm text-indigo-600" onclick="addNode()">+ Add node</button>
      </section>

      <!-- Bars -->
      <section>
        <h2 class="font-semibold mb-1">Bars</h2>
        <div id="bars" class="space-y-2"></div>
        <button class="no-print text-sm text-indigo-600" onclick="addBar()">+ Add bar</button>
      </section>

      <!-- Supports -->
      <section>
        <h2 class="font-semibold mb-1">Supports</h2>
        <div id="supports" class="space-y-2"></div>
        <button class="no-print text-sm text-indigo-600" onclick="addSupport()">+ Add support</button>
      </section>

      <!-- Loads -->
      <section>
        <h2 class="font-semibold mb-1">Loads</h2>
        <p class="text-xs text-zinc-500">Node loads: Fx (kN +→), Fz (kN ↓), M (kNm +ccw). UDL: w (kN/m ↓) in global Z.</p>
        <div id="nodeloads" class="space-y-2"></div>
        <button class="no-print text-sm text-indigo-600 mr-3" onclick="addNodeLoad()">+ Add node load</button>
        <div id="udlloads" class="mt-2 space-y-2"></div>
        <button class="no-print text-sm text-indigo-600" onclick="addUdlLoad()">+ Add bar UDL</button>
      </section>

      <section class="text-xs text-zinc-500">
        <p><span class="font-semibold">Tip:</span> This MVP mirrors Backbone’s flow: define nodes → bars → supports → loads → run → use the spy.</p>
      </section>
    </aside>

    <!-- Main: graphics + results -->
    <main class="space-y-4">
      <!-- Split into three separate graphs with adjustable scales + axis notation -->
      <section class="grid md:grid-cols-3 gap-4">
        <div class="card bg-white p-4">
          <h2 class="font-semibold">Geometry</h2>
          <div class="text-sm text-zinc-500 flex items-center gap-2">
            Zoom (m/px): <input id="zoomInput" type="number" step="0.001" class="w-24 text-xs border rounded p-0.5" placeholder="auto"/>
          </div>
          <canvas id="viewStructure" class="w-full h-[300px] bg-zinc-100 rounded-xl mt-2"></canvas>
          <div class="mt-1 text-[11px] text-zinc-500">Axes show x (m) and z (m). Legend displays 1 px scale.</div>
        </div>

        <div class="card bg-white p-4">
          <h2 class="font-semibold">Deflection</h2>
          <div class="text-sm text-zinc-500 flex items-center gap-2">
            Scale (×): <input id="deflScaleInput" type="number" step="0.1" value="1" class="w-20 text-xs border rounded p-0.5"/>
          </div>
          <canvas id="viewDefl" class="w-full h-[300px] bg-zinc-100 rounded-xl mt-2"></canvas>
          <div class="mt-1 text-[11px] text-zinc-500">Green line = displaced centerline × scale.</div>
        </div>

        <div class="card bg-white p-4">
          <h2 class="font-semibold">Moment</h2>
          <div class="text-sm text-zinc-500 flex items-center gap-2">
            px per kNm: <input id="momentScaleInput" type="number" step="0.01" value="0.02" class="w-24 text-xs border rounded p-0.5"/>
          </div>
          <canvas id="viewMoment" class="w-full h-[300px] bg-zinc-100 rounded-xl mt-2"></canvas>
          <div class="mt-1 text-[11px] text-zinc-500">Purple polygon = end-moment diagram (qualitative).</div>
        </div>
      </section>

      <section class="grid md:grid-cols-2 gap-4">
        <div class="card bg-white p-4">
          <h2 class="font-semibold mb-2">Result spy – Nodes</h2>
          <div id="nodeResults" class="mono text-xs overflow-auto max-h-64"></div>
        </div>
        <div class="card bg-white p-4">
          <h2 class="font-semibold mb-2">Result spy – Bars (end actions, local)</h2>
          <div id="barResults" class="mono text-xs overflow-auto max-h-64"></div>
        </div>
      </section>
    </main>
  </div>

<script>
// --------------------------- Data Model ---------------------------
const model = {
  materials: [], // {id,name,E(GPa),rho(kN/m3)} rho optional
  nodes: [],     // {id,x,z}
  bars: [],      // {id,i,j,matId,A(m2),I(m4),releaseI:{ux:false,uz:false,rz:false},releaseJ:{...}}
  supports: [],  // {node, ux, uz, rz} booleans (fixed DOF)
  nodeloads: [], // {node, Fx, Fz, M}
  udls: [],      // {bar, w} downward kN/m in GLOBAL Z
};

// --------------------------- UI Builders ---------------------------
function mkRow(html){ const d=document.createElement('div'); d.className='grid grid-cols-12 gap-2 items-center'; d.innerHTML=html; return d; }
function num(v){ v = parseFloat(v); return isFinite(v)? v : 0; }

function renderMaterials(){
  const host=document.getElementById('materials'); host.innerHTML='';
  model.materials.forEach((m,idx)=>{
    const row = mkRow(`
      <input class="col-span-4 input" value="${m.name}" onchange="model.materials[${idx}].name=this.value"/>
      <label class="col-span-4 text-xs">E (GPa)<input type="number" step="0.01" class="w-full" value="${m.E}" onchange="model.materials[${idx}].E=num(this.value)"/></label>
      <label class="col-span-3 text-xs">ρ (kN/m³)<input type="number" step="0.01" class="w-full" value="${m.rho??0}" onchange="model.materials[${idx}].rho=num(this.value)"/></label>
      <button class="col-span-1 text-red-600" onclick="model.materials.splice(${idx},1); renderAll()">✕</button>
    `);
    host.appendChild(row);
  });
}

function renderNodes(){
  const host=document.getElementById('nodes'); host.innerHTML='';
  model.nodes.forEach((n,idx)=>{
    const row = mkRow(`
      <span class="col-span-2 text-sm">N${n.id}</span>
      <label class="col-span-4 text-xs">x (m)<input type="number" step="0.001" class="w-full" value="${n.x}" onchange="model.nodes[${idx}].x=num(this.value); draw()"/></label>
      <label class="col-span-4 text-xs">z (m)<input type="number" step="0.001" class="w-full" value="${n.z}" onchange="model.nodes[${idx}].z=num(this.value); draw()"/></label>
      <button class="col-span-2 text-red-600" onclick="model.nodes.splice(${idx},1); renumber(); renderAll()">✕</button>
    `);
    host.appendChild(row);
  });
}

function renderBars(){
  const host=document.getElementById('bars'); host.innerHTML='';
  const matOpts = model.materials.map(m=>`<option value="${m.id}">${m.name}</option>`).join('');
  model.bars.forEach((b,idx)=>{
    const row = mkRow(`
      <span class="col-span-1 text-sm">B${b.id}</span>
      <label class="col-span-2 text-xs">i<input type="number" class="w-full" value="${b.i}" onchange="model.bars[${idx}].i=parseInt(this.value)||1; draw()"/></label>
      <label class="col-span-2 text-xs">j<input type="number" class="w-full" value="${b.j}" onchange="model.bars[${idx}].j=parseInt(this.value)||1; draw()"/></label>
      <label class="col-span-3 text-xs">Mat<select class="w-full" onchange="model.bars[${idx}].matId=parseInt(this.value);">
        ${matOpts}
      </select></label>
      <label class="col-span-2 text-xs">A m²<input type="number" step="0.000001" class="w-full" value="${b.A}" onchange="model.bars[${idx}].A=num(this.value)"/></label>
      <label class="col-span-2 text-xs">I m⁴<input type="number" step="0.000000001" class="w-full" value="${b.I}" onchange="model.bars[${idx}].I=num(this.value)"/></label>
      <div class="col-span-12 grid grid-cols-12 gap-2 text-[11px] text-zinc-600">
        <span class="col-span-12">Releases (pin ends):</span>
        <label class="col-span-2">i-rz <input type="checkbox" ${b.releaseI.rz?'checked':''} onchange="model.bars[${idx}].releaseI.rz=this.checked"></label>
        <label class="col-span-2">j-rz <input type="checkbox" ${b.releaseJ.rz?'checked':''} onchange="model.bars[${idx}].releaseJ.rz=this.checked"></label>
      </div>
      <button class="col-span-12 text-red-600 text-left" onclick="model.bars.splice(${idx},1); renumber(); renderAll()">✕ Remove</button>
    `);
    row.querySelector('select').value = b.matId;
    host.appendChild(row);
  });
}

function renderSupports(){
  const host=document.getElementById('supports'); host.innerHTML='';
  model.supports.forEach((s,idx)=>{
    const row = mkRow(`
      <label class="col-span-3 text-xs">Node<input type="number" class="w-full" value="${s.node}" onchange="model.supports[${idx}].node=parseInt(this.value)||1; draw()"/></label>
      <label class="col-span-3 text-xs">ux <input type="checkbox" ${s.ux?'checked':''} onchange="model.supports[${idx}].ux=this.checked"></label>
      <label class="col-span-3 text-xs">uz <input type="checkbox" ${s.uz?'checked':''} onchange="model.supports[${idx}].uz=this.checked"></label>
      <label class="col-span-3 text-xs">rz <input type="checkbox" ${s.rz?'checked':''} onchange="model.supports[${idx}].rz=this.checked"></label>
      <button class="col-span-12 text-red-600 text-left" onclick="model.supports.splice(${idx},1); renderSupports(); draw()">✕ Remove</button>
    `);
    host.appendChild(row);
  });
}

function renderNodeLoads(){
  const host=document.getElementById('nodeloads'); host.innerHTML='';
  model.nodeloads.forEach((l,idx)=>{
    const row = mkRow(`
      <label class="col-span-3 text-xs">Node<input type="number" class="w-full" value="${l.node}" onchange="model.nodeloads[${idx}].node=parseInt(this.value)||1"></label>
      <label class="col-span-3 text-xs">Fx kN<input type="number" step="0.01" class="w-full" value="${l.Fx}" onchange="model.nodeloads[${idx}].Fx=num(this.value)"></label>
      <label class="col-span-3 text-xs">Fz kN<input type="number" step="0.01" class="w-full" value="${l.Fz}" onchange="model.nodeloads[${idx}].Fz=num(this.value)"></label>
      <label class="col-span-3 text-xs">M kNm<input type="number" step="0.01" class="w-full" value="${l.M}" onchange="model.nodeloads[${idx}].M=num(this.value)"></label>
      <button class="col-span-12 text-red-600 text-left" onclick="model.nodeloads.splice(${idx},1); renderNodeLoads()">✕ Remove</button>
    `);
    host.appendChild(row);
  });
}

function renderUdlLoads(){
  const host=document.getElementById('udlloads'); host.innerHTML='';
  model.udls.forEach((l,idx)=>{
    const row = mkRow(`
      <label class="col-span-4 text-xs">Bar<input type="number" class="w-full" value="${l.bar}" onchange="model.udls[${idx}].bar=parseInt(this.value)||1"></label>
      <label class="col-span-6 text-xs">w kN/m (down)<input type="number" step="0.01" class="w-full" value="${l.w}" onchange="model.udls[${idx}].w=num(this.value)"></label>
      <button class="col-span-2 text-red-600" onclick="model.udls.splice(${idx},1); renderUdlLoads()">✕</button>
    `);
    host.appendChild(row);
  });
}

function renderAll(){
  renderMaterials();
  renderNodes();
  renderBars();
  renderSupports();
  renderNodeLoads();
  renderUdlLoads();
  draw();
}

function renumber(){
  model.nodes.forEach((n,i)=>n.id=i+1);
  model.bars.forEach((b,i)=>b.id=i+1);
}

function addMaterial(){
  const id = model.materials.length+1;
  model.materials.push({id,name:`Steel S${id}`,E:210,rho:78.5});
  renderMaterials();
}
function addNode(){ const id=model.nodes.length+1; model.nodes.push({id,x: (id-1)*2, z:0}); renderNodes(); draw(); }
function addBar(){ const id=model.bars.length+1; const mat=model.materials[0]?.id||1; model.bars.push({id,i:id,j:id+1,matId:mat,A:0.02,I:8e-5,releaseI:{ux:false,uz:false,rz:false},releaseJ:{ux:false,uz:false,rz:false}}); renderBars(); draw(); }
function addSupport(){ model.supports.push({node:1,ux:true,uz:true,rz:true}); renderSupports(); draw(); }
function addNodeLoad(){ model.nodeloads.push({node:1,Fx:0,Fz:-10,M:0}); renderNodeLoads(); }
function addUdlLoad(){ model.udls.push({bar:1,w:-5}); renderUdlLoads(); }

// --------------------------- Solver (2D Frame) ---------------------------
// DOFs per node: [ux, uz, rz]; units: E in GPa, A m2, I m4, loads kN, kNm
function assembleAndSolve(){
  const nn = model.nodes.length; if(nn===0) return null;
  const dof = nn*3;
  let K = math.zeros(dof,dof);
  let F = math.zeros(dof,1);

  // helper maps
  const nodeIndex = (nid)=> (nid-1)*3; // returns base index
  const getNode = (id)=> model.nodes.find(n=>n.id===id);
  const getMat = (id)=> model.materials.find(m=>m.id===id);

  // Equivalent nodal loads from UDLs (global downward): we project to local then to global

  // Element assembly
  const elemForcesLocal = []; // store for reporting
  const elemGeometry = [];

  for(const b of model.bars){
    const ni = getNode(b.i), nj = getNode(b.j); if(!ni||!nj) continue;
    const dx = nj.x - ni.x; const dz = nj.z - ni.z; const L = Math.hypot(dx,dz); if(L<1e-9) continue;
    const c = dx/L, s = dz/L;
    const R = math.matrix([
      [ c,  s, 0,   0,  0, 0],
      [-s,  c, 0,   0,  0, 0],
      [ 0,  0, 1,   0,  0, 0],
      [ 0,  0, 0,   c,  s, 0],
      [ 0,  0, 0,  -s,  c, 0],
      [ 0,  0, 0,   0,  0, 1],
    ]);
    const E = (getMat(b.matId)?.E ?? 210) * 1e9; // Pa
    const A = b.A; const I = b.I;

    // Local stiffness for 2D frame element
    const EA_L = E*A/L;
    const EI = E*I;
    const kLocal = math.matrix([
      [ EA_L,        0,           0, -EA_L,        0,           0],
      [    0, 12*EI/L**3,  6*EI/L**2,     0, -12*EI/L**3,  6*EI/L**2],
      [    0,  6*EI/L**2,     4*EI/L,     0,  -6*EI/L**2,     2*EI/L],
      [-EA_L,        0,           0,  EA_L,        0,           0],
      [    0, -12*EI/L**3, -6*EI/L**2,     0,  12*EI/L**3, -6*EI/L**2],
      [    0,  6*EI/L**2,     2*EI/L,     0,  -6*EI/L**2,     4*EI/L],
    ]);

    // Releases (only end rotations rz supported in MVP) via big-number method
    const kLoc = math.clone(kLocal);
    const big = 1e12;
    if(b.releaseI?.rz){ kLoc.subset(math.index(2,2), kLoc.get([2,2]) + big); }
    if(b.releaseJ?.rz){ kLoc.subset(math.index(5,5), kLoc.get([5,5]) + big); }

    const kGlobal = math.multiply(math.transpose(R), kLoc, R);

    // Assemble into K
    const map = [nodeIndex(b.i)+0, nodeIndex(b.i)+1, nodeIndex(b.i)+2, nodeIndex(b.j)+0, nodeIndex(b.j)+1, nodeIndex(b.j)+2];
    for(let a=0;a<6;a++){
      for(let b2=0;b2<6;b2++){
        K.subset(math.index(map[a],map[b2]), K.get([map[a],map[b2]]) + kGlobal.get([a,b2]));
      }
    }

    // UDL -> local fixed end forces (acting in local -y). Our global downward w becomes local w_y = w*c (projection)
    const udl = model.udls.find(u=>u.bar===b.id);
    let fLocal = math.zeros(6,1);
    if(udl && Math.abs(udl.w) > 0){
      const w = udl.w * c; // crude: component along local -y
      const wL = w*L;
      fLocal = math.matrix([[0],[ wL/2],[ w*L*L/12],[0],[ wL/2],[ -w*L*L/12]]);
    }

    elemGeometry.push({id:b.id, i:b.i, j:b.j, L, c, s, R, kLoc});
    elemForcesLocal.push({id:b.id, fLocal});
  }

  // Assemble Nodal loads
  for(const l of model.nodeloads){
    const base = nodeIndex(l.node);
    if(base>=0){
      F.subset(math.index(base+0,0), F.get([base+0,0]) + l.Fx*1e3);
      F.subset(math.index(base+1,0), F.get([base+1,0]) + l.Fz*1e3);
      F.subset(math.index(base+2,0), F.get([base+2,0]) + l.M*1e3);
    }
  }
  // Equivalent nodal loads from UDLs
  for(const e of elemGeometry){
    const fel = elemForcesLocal.find(x=>x.id===e.id).fLocal;
    const feg = math.multiply(math.transpose(e.R), fel);
    const map = [nodeIndex(e.i)+0, nodeIndex(e.i)+1, nodeIndex(e.i)+2, nodeIndex(e.j)+0, nodeIndex(e.j)+1, nodeIndex(e.j)+2];
    for(let a=0;a<6;a++){
      F.subset(math.index(map[a],0), F.get([map[a],0]) + feg.get([a,0])*1e3);
    }
  }

  // Boundary conditions (supports)
  const fixed = new Set();
  for(const s of model.supports){
    const base = nodeIndex(s.node);
    if(base<0) continue;
    if(s.ux) fixed.add(base+0);
    if(s.uz) fixed.add(base+1);
    if(s.rz) fixed.add(base+2);
  }

  // Apply restraints via big number method
  const bigK = 1e18;
  fixed.forEach(d=>{
    K.subset(math.index(d,d), K.get([d,d]) + bigK);
  });

  // Solve KU = F
  let U;
  try{
    U = math.lusolve(K,F);
  }catch(err){
    console.error(err);
    alert('Solver failed – model may be unstable or ill-posed.');
    return null;
  }

  // Recover element end forces (local)
  const barEndForces = [];
  for(const e of elemGeometry){
    const map = [nodeIndex(e.i)+0, nodeIndex(e.i)+1, nodeIndex(e.i)+2, nodeIndex(e.j)+0, nodeIndex(e.j)+1, nodeIndex(e.j)+2];
    const Ug = math.matrix([ [U.get([map[0],0])],[U.get([map[1],0])],[U.get([map[2],0])],[U.get([map[3],0])],[U.get([map[4],0])],[U.get([map[5],0])] ]);
    const Ul = math.multiply(e.R, Ug);
    const fel = elemForcesLocal.find(x=>x.id===e.id).fLocal;
    const ql = math.add(math.multiply(e.kLoc, Ul), math.multiply(-1, fel));
    barEndForces.push({id:e.id, ql});
  }

  return {U, barEndForces, geom: elemGeometry};
}

// --------------------------- Drawing (3 panels) ---------------------------
function draw(){
  const canvas = document.getElementById('viewStructure');
  const ctx = canvas.getContext('2d');
  const W = canvas.width = canvas.clientWidth;
  const H = canvas.height = canvas.clientHeight;
  ctx.clearRect(0,0,W,H);

  if(model.nodes.length===0){
    ctx.fillStyle='#64748b';
    ctx.fillText('Add nodes, bars, supports, loads…', 20, 24);
    return;
  }

  // extents
  let xs = model.nodes.map(n=>n.x), zs = model.nodes.map(n=>n.z);
  const minx = Math.min(...xs), maxx=Math.max(...xs);
  const minz = Math.min(...zs), maxz=Math.max(...zs);
  const pad = 0.2 * Math.max(1, maxx-minx, maxz-minz);
  let sx = (W-40)/(maxx-minx+2*pad);
  let sz = (H-40)/(maxz-minz+2*pad);
  let scale = Math.min(sx,sz);
  const zoomVal = parseFloat(document.getElementById('zoomInput')?.value);
  if(!isNaN(zoomVal) && zoomVal>0){ scale = 1/zoomVal; }
  const ox = 20 - (minx - pad)*scale;
  const oz = 20 - (minz - pad)*scale;
  function X(x){ return ox + x*scale; }
  function Z(z){ return H - (oz + z*scale); }

  // axes + legend
  ctx.strokeStyle='#9ca3af'; ctx.lineWidth=1; ctx.beginPath();
  ctx.moveTo(30,H-30); ctx.lineTo(W-10,H-30); // x
  ctx.moveTo(30,H-30); ctx.lineTo(30,10); // z
  ctx.stroke();
  ctx.fillStyle='#6b7280'; ctx.font='10px sans-serif';
  ctx.fillText('x (m)', W-40, H-35);
  ctx.fillText('z (m)', 10, 20);
  ctx.fillText(`1 px = ${(1/scale).toFixed(3)} m`, 35, H-10);

  // bars
  ctx.lineWidth=2; ctx.strokeStyle='#3b82f6';
  for(const b of model.bars){
    const ni = model.nodes.find(n=>n.id===b.i), nj = model.nodes.find(n=>n.id===b.j); if(!ni||!nj) continue;
    ctx.beginPath(); ctx.moveTo(X(ni.x), Z(ni.z)); ctx.lineTo(X(nj.x), Z(nj.z)); ctx.stroke();
  }
  // nodes
  for(const n of model.nodes){
    ctx.fillStyle='#0ea5e9'; ctx.beginPath(); ctx.arc(X(n.x), Z(n.z), 4, 0, Math.PI*2); ctx.fill();
  }
  // supports
  for(const s of model.supports){
    const n = model.nodes.find(n=>n.id===s.node); if(!n) continue;
    ctx.fillStyle='#111827';
    if(s.ux||s.uz||s.rz){ ctx.fillRect(X(n.x)-6, Z(n.z)+6, 12, 6); }
  }
}

// Plot results and update spy panes (and draw deflection/moment panels)
function run(){
  const res = assembleAndSolve();
  if(!res) return;
  const {U, barEndForces, geom} = res;

  // ---------- world->screen shared ----------
  const cS = document.getElementById('viewStructure');
  const W = cS.clientWidth, H = cS.clientHeight;
  let xs = model.nodes.map(n=>n.x), zs = model.nodes.map(n=>n.z);
  const minx = Math.min(...xs), maxx=Math.max(...xs);
  const minz = Math.min(...zs), maxz=Math.max(...zs);
  const pad = 0.2 * Math.max(1, maxx-minx, maxz-minz);
  let sx = (W-40)/(maxx-minx+2*pad);
  let sz = (H-40)/(maxz-minz+2*pad);
  let scale = Math.min(sx,sz);
  const zoomVal = parseFloat(document.getElementById('zoomInput')?.value);
  if(!isNaN(zoomVal) && zoomVal>0){ scale = 1/zoomVal; }
  const ox = 20 - (minx - pad)*scale;
  const oz = 20 - (minz - pad)*scale;
  const X=(x)=>ox + x*scale;
  const Z=(z)=>H - (oz + z*scale);
  function axes(ctx,w,h){
    ctx.strokeStyle='#9ca3af'; ctx.lineWidth=1; ctx.beginPath();
    ctx.moveTo(30,h-30); ctx.lineTo(w-10,h-30); ctx.moveTo(30,h-30); ctx.lineTo(30,10); ctx.stroke();
    ctx.fillStyle='#6b7280'; ctx.font='10px sans-serif';
    ctx.fillText('x (m)', w-40, h-35); ctx.fillText('z (m)', 10, 20); ctx.fillText(`1 px = ${(1/scale).toFixed(3)} m`, 35, h-10);
  }

  // ---------- Structure panel ----------
  draw(); // reuse

  // ---------- Deflection panel ----------
  const cd = document.getElementById('viewDefl');
  const ctxD = cd.getContext('2d');
  cd.width = cd.clientWidth; cd.height = cd.clientHeight;
  ctxD.clearRect(0,0,cd.width,cd.height); axes(ctxD,cd.width,cd.height);
  const dScale = parseFloat(document.getElementById('deflScaleInput')?.value)||1;
  ctxD.lineWidth=1.5; ctxD.strokeStyle='#94a3b8';
  for(const b of model.bars){
    const ni = model.nodes.find(n=>n.id===b.i), nj = model.nodes.find(n=>n.id===b.j); if(!ni||!nj) continue;
    ctxD.beginPath(); ctxD.moveTo(X(ni.x), Z(ni.z)); ctxD.lineTo(X(nj.x), Z(nj.z)); ctxD.stroke();
  }
  ctxD.strokeStyle='#10b981'; ctxD.lineWidth=2;
  for(const b of model.bars){
    const ni = model.nodes.find(n=>n.id===b.i), nj = model.nodes.find(n=>n.id===b.j); if(!ni||!nj) continue;
    const ui = [U.get([(b.i-1)*3+0,0]), U.get([(b.i-1)*3+1,0])];
    const uj = [U.get([(b.j-1)*3+0,0]), U.get([(b.j-1)*3+1,0])];
    ctxD.beginPath();
    ctxD.moveTo(X(ni.x + ui[0]/1000*dScale), Z(ni.z + ui[1]/1000*dScale));
    ctxD.lineTo(X(nj.x + uj[0]/1000*dScale), Z(nj.z + uj[1]/1000*dScale));
    ctxD.stroke();
  }

  // ---------- Moment panel ----------
  const cm = document.getElementById('viewMoment');
  const ctxM = cm.getContext('2d');
  cm.width = cm.clientWidth; cm.height = cm.clientHeight;
  ctxM.clearRect(0,0,cm.width,cm.height); axes(ctxM,cm.width,cm.height);
  const pxPerkNm = parseFloat(document.getElementById('momentScaleInput')?.value)||0.02;
  ctxM.lineWidth=1.5; ctxM.strokeStyle='#8b5cf6';
  for(const e of geom){
    const ni = model.nodes.find(n=>n.id===e.i), nj = model.nodes.find(n=>n.id===e.j); if(!ni||!nj) continue;
    const ql = barEndForces.find(q=>q.id===e.id).ql;
    const Mi = ql.get([2,0]) / 1e3; // kNm
    const Mj = ql.get([5,0]) / 1e3;
    const nx = X(ni.x), nz = Z(ni.z);
    const jx = X(nj.x), jz = Z(nj.z);
    const ex = (jx-nx), ez=(jz-nz); const len = Math.hypot(ex,ez);
    const ux = -ez/len, uz = ex/len;
    ctxM.beginPath();
    ctxM.moveTo(nx, nz);
    ctxM.lineTo(nx + ux*Mi*pxPerkNm, nz + uz*Mi*pxPerkNm);
    ctxM.lineTo(jx + ux*Mj*pxPerkNm, jz + uz*Mj*pxPerkNm);
    ctxM.lineTo(jx, jz);
    ctxM.stroke();
  }

  // ---------- Spy tables ----------
  const NR = document.getElementById('nodeResults');
  NR.innerHTML = '<div class="mb-1">Displacements (U in mm, θ in mrad)</div>';
  let html = '<table class="w-full"><tr class="text-zinc-500"><th class="text-left">Node</th><th>Ux</th><th>Uz</th><th>Rz</th></tr>';
  for(const n of model.nodes){
    const ui = U.get([(n.id-1)*3+0,0]);
    const uz = U.get([(n.id-1)*3+1,0]);
    const rz = U.get([(n.id-1)*3+2,0]);
    html += `<tr><td>N${n.id}</td><td>${(ui).toExponential(2)}</td><td>${(uz).toExponential(2)}</td><td>${(rz*1000).toExponential(2)}</td></tr>`;
  }
  html += '</table>';
  NR.innerHTML += html;

  const BR = document.getElementById('barResults');
  let bhtml = '<table class="w-full"><tr class="text-zinc-500"><th class="text-left">Bar</th><th>Fx_i</th><th>Fz_i</th><th>Mi</th><th>Fx_j</th><th>Fz_j</th><th>Mj</th></tr>';
  for(const be of barEndForces){
    const q = be.ql; // N, N, Nmm
    bhtml += `<tr><td>B${be.id}</td>
      <td>${(q.get([0,0])/1e3).toFixed(2)}</td>
      <td>${(q.get([1,0])/1e3).toFixed(2)}</td>
      <td>${(q.get([2,0])/1e3).toFixed(2)}</td>
      <td>${(q.get([3,0])/1e3).toFixed(2)}</td>
      <td>${(q.get([4,0])/1e3).toFixed(2)}</td>
      <td>${(q.get([5,0])/1e3).toFixed(2)}</td></tr>`;
  }
  bhtml += '</table>';
  BR.innerHTML = bhtml;
}

// --------------------------- Sample Model ---------------------------
function loadSample(){
  model.materials = [ {id:1,name:'Steel S355',E:210,rho:78.5} ];
  model.nodes = [
    {id:1,x:0,z:0},
    {id:2,x:5,z:0},
    {id:3,x:10,z:0}
  ];
  model.bars = [
    {id:1,i:1,j:2,matId:1,A:0.02,I:8e-5,releaseI:{ux:false,uz:false,rz:false},releaseJ:{ux:false,uz:false,rz:false}},
    {id:2,i:2,j:3,matId:1,A:0.02,I:8e-5,releaseI:{ux:false,uz:false,rz:false},releaseJ:{ux:false,uz:false,rz:false}},
  ];
  model.supports = [ {node:1,ux:true,uz:true,rz:true}, {node:3,ux:false,uz:true,rz:false} ];
  model.nodeloads = [ {node:2,Fx:0,Fz:-50,M:0} ];
  model.udls = [ {bar:1,w:-5} ];
  renderAll();
}

// --------------------------- Example cases ---------------------------
function loadCantilever(){
  model.materials = [ {id:1,name:'Steel',E:210,rho:78.5} ];
  model.nodes = [ {id:1,x:0,z:0}, {id:2,x:5,z:0} ];
  model.bars = [ {id:1,i:1,j:2,matId:1,A:0.02,I:8e-5,releaseI:{ux:false,uz:false,rz:false},releaseJ:{ux:false,uz:false,rz:false}} ];
  model.supports = [ {node:1,ux:true,uz:true,rz:true} ];
  model.nodeloads = [ {node:2,Fx:0,Fz:-50,M:0} ];
  model.udls = [];
  renderAll();
}
function loadSimplySupported(){
  model.materials = [ {id:1,name:'Steel',E:210,rho:78.5} ];
  model.nodes = [ {id:1,x:0,z:0}, {id:2,x:6,z:0} ];
  model.bars = [ {id:1,i:1,j:2,matId:1,A:0.02,I:8e-5,releaseI:{ux:false,uz:false,rz:false},releaseJ:{ux:false,uz:false,rz:false}} ];
  model.supports = [ {node:1,ux:true,uz:true,rz:true}, {node:2,ux:false,uz:true,rz:true} ];
  model.nodeloads = [];
  model.udls = [ {bar:1,w:-10} ];
  renderAll();
}
function loadPortalFrame(){
  model.materials = [ {id:1,name:'Steel',E:210,rho:78.5} ];
  model.nodes = [ {id:1,x:0,z:0}, {id:2,x:0,z:4}, {id:3,x:6,z:4}, {id:4,x:6,z:0} ];
  model.bars = [
    {id:1,i:1,j:2,matId:1,A:0.02,I:8e-5,releaseI:{ux:false,uz:false,rz:false},releaseJ:{ux:false,uz:false,rz:false}},
    {id:2,i:2,j:3,matId:1,A:0.02,I:8e-5,releaseI:{ux:false,uz:false,rz:false},releaseJ:{ux:false,uz:false,rz:false}},
    {id:3,i:3,j:4,matId:1,A:0.02,I:8e-5,releaseI:{ux:false,uz:false,rz:false},releaseJ:{ux:false,uz:false,rz:false}}
  ];
  model.supports = [ {node:1,ux:true,uz:true,rz:true}, {node:4,ux:true,uz:true,rz:true} ];
  model.nodeloads = [ {node:2,Fx:20,Fz:0,M:0} ];
  model.udls = [];
  renderAll();
}
function loadTwoSpan(){
  model.materials = [ {id:1,name:'Steel',E:210,rho:78.5} ];
  model.nodes = [ {id:1,x:0,z:0}, {id:2,x:5,z:0}, {id:3,x:10,z:0} ];
  model.bars = [
    {id:1,i:1,j:2,matId:1,A:0.02,I:8e-5,releaseI:{ux:false,uz:false,rz:false},releaseJ:{ux:false,uz:false,rz:false}},
    {id:2,i:2,j:3,matId:1,A:0.02,I:8e-5,releaseI:{ux:false,uz:false,rz:false},releaseJ:{ux:false,uz:false,rz:false}}
  ];
  model.supports = [ {node:1,ux:true,uz:true,rz:true}, {node:3,ux:false,uz:true,rz:true} ];
  model.nodeloads = [ {node:2,Fx:0,Fz:-50,M:0} ];
  model.udls = [];
  renderAll();
}

// --------------------------- Init ---------------------------
function init(){
  document.getElementById('btnSample').addEventListener('click', loadSample);
  document.getElementById('btnRun').addEventListener('click', run);
  if(model.materials.length===0) addMaterial();
  if(model.nodes.length===0){ addNode(); addNode(); }
  draw();
}
window.addEventListener('load', init);
</script>
</body>
</html>
